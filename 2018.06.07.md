# 2018.06.07 TIL
## CSharp
### foreach
```
using System;
namespace CSharp
{
	class Foreach
	{
		static void Main(string[] args)
		{
			int[] arr = new int[]{0, 1, 2, 3, 4};

			foreach (int a in arr)
			{
				Console.WriteLine(a);
			}
		}
	}
}
```
결과
```
0
1
2
3
4
```
1. foreach문을 사용하는 형식에 유의할 것. 
	foreach(int a int arr) {}

### 가변길이 매개변수
```
namespace CSharp
{
	class UsingParams
	{
		static int Sum(params int[] args)
		{
			int sum = 0;
			for (int i = 0; i < args.Length; i++)
			{
				sum += args[i];
			}
			return sum;
		}

		static void Main(string[] args)
		{
			int sum = Sum(3, 4, 5, 6, 7);
			Console.WriteLine("Sum : {0}", sum);
		}
}
```
결과
```
Sum : 25
```
1. 함수를 사용할 때에는 (int, int, int, ...)로 변수를 전달하더라도, 매개변수를 받는 함수에서는 params int[]형식으로 사용하도록 한다.


### override, sealed, new
```
using System;
namespace CSharp
{
	class Base
	{
		public void MyMethod()
		{
			Console.WriteLine("Base");
		}
	}

	class Derived : Base
	{
		public new void MyMethod()
		{
			Console.WriteLine("Derived");
		}
	}

	class MethodHiding
	{
		static void Main(string[] args)
		{
			Base baseObj = new Base();
			baseObj.MyMethod();

			Derived derivedObj = new Derived();
			derivedObj.MyMethod();

			Base Obj = new Derived();
			Obj.MyMethod();
		}
	}
}
```
결과
```
Base
Derived
Base
```
1. 메소드 숨기기: 기반클래스에서 구현된 메소드를 감추고 파생클래스에서 구현된 버전만을 보여준다.
2. 파생 클래스의 메소드를 new 한정자로 수식한다.
3. 만약 derived의 MyMethod가 override한정자이고, Base의 MyMethod가 virtual한정자이면, 출력 결과의 3번째 줄은 Derived로 출력되었을것이다.
4. 만약 derived의 MyMethod가 sealed override한정자이면, Derived의 파생클래스는 MyMethod()를 사용할 수 없다.


### 확장메소드
```
using System;
namespace CSharp
{
	public static class IntegerExtension
	{
		public static int Power(this int myInt, int exponent)
		{
			int result = myInt;
			for (int i = 1; i < exponent; i++)
				result = result * myInt;

			return result;
		}
	}

	class MainApp
	{
		static void Main(string[] args)
		{
			int a = 3;
			Console.WriteLine("{0}^{1} : {2}", a, 4, a.Power(4));
		}
	}
}
```
결과
```
3^4 : 81
```
1. 확장 메소드 : 기존클래스의 기능을 확장.
2. 확장 메소드의 조건 : 메소드를 static 한정자로 선언하고, 메소드의 첫번째 매개 변수는 반드시 this와 확장하고자 하는 클래스의 인스턴스여야 한다. 그 뒤로는 매개변수의 목록이 따른다. 이 메소드의 클래스 역시 static이어야 한다.
3. 위의 예제로 본다면, 마치 Power()가 원래부터 int클래스의 메소드였던 것처럼 사용됨을 알 수 있다.


### structure
```
using System;
namespace CSharp
{
	struct Point
	{
		public int x;
		public int y;

		public Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		public override string ToString()
		{
			return string.Format("{0}, {1}", x, y);
		}
	}

	class MainApp
	{
		static void Main(string[] args)
		{
			Point p1 = new Point(10, 20);
			Console.WriteLine(p1);

			Point p2 = p1;
			p2.y = 30;

			Point p3;
			p3.x = 40;
			p3.y = 50;

			Console.WriteLine(p1);
			Console.WriteLine(p2);
			Console.WriteLine(p3);
		}
	}
}

```
결과
```
10, 20
10, 20
10, 30
40, 50
```
1. 클래스와의 차이점
	-	클래스는 참조형식이라 얕은 복사가 이루어지는 반면, 구조체는 값 형식이라 깊은 복사가 이루어진다.
	-	인스턴스를 생성하기위해서는 클래스는 생성자가 필요하지만, 구조체는 선언만으로 생성가능하다.(그러나 사용하기 위해서는 후에 모든 내용을 초기화해야한다.)
	-	클래스는 매개변수 없는 생성자 선언이 가능하지만, 구조체는 매개변수 없는 생성자 선언이 불가능하다. 


### 인터페이스 상속
```
using System;
namespace CSharp
{
	interface ILogger
	{
		void WriteLog(string message);
	}

	interface IFormattableLogger : ILogger
	{
		void WriteLog(string format, params Object[] args);
	}

	class ConsoleLogger : IFormattableLogger
	{
		public void WriteLog(string message)
		{
			Console.WriteLine("{0}", message);
		}

		public void WriteLog(string format, params Object[] args)
		{
			String message = String.Format(format, args);
			Console.WriteLine("{0}", message);
		}
	}

	class MainApp
	{
		static void Main(string[] args)
		{
			IFormattableLogger logger = new ConsoleLogger();
			logger.WriteLog("Hello World");
			logger.WriteLog("{0} + {1} = {2}", 1, 1, 2);
		}
	}
}
```
결과
```
Hello World
1 + 1 = 2
```
1. 클래스는 물론 인터페이스도 인터페이스를 상속할 수 있다.
2. 파생 인터페이스는 기반인터페이스와 자신의 메소드를 동시에 가진다. 따라서 파생 인터페이스를 상속하는 클래스는 파생인터페이스와 기반 인터페이스의 메소드를 모두 구현해야한다.
3. 다중상속을 위해서는 class ClassName : I1, I2 {}의 혁식으로 할 수 있다.


### abstract class
```
using System;
namespace CSharp
{
	abstract class AbstractBase
	{
		protected void PrivateMethod()
		{
			Console.WriteLine("AbstractBase Private");
		}

		public void PublicMethod()
		{
			Console.WriteLine("AbstractBase Public");
		}

		public abstract void AbstractMethod();
	}

	class Derived : AbstractBase
	{
		public override void AbstractMethod()
		{
			Console.WriteLine("Derived Abstract");
			PrivateMethod();
		}
	}

	class MainApp
	{
		static void Main(string[] args)
		{
			AbstractBase obj = new Derived();
			obj.AbstractMethod();
			obj.PublicMethod();
		}
	}
}
```
결과
```
Derived Abstract
AbstractBase Private
AbstractBase Public
```

1. 추상클래스 : 구현은 가지지만 인스턴스를 가지지 못하는 클래스.
2. 인터페이스의 역할을 하는 (구현x) 추상 메소드를 가질 수 있다.
3. 추상메소드는 추상 클래스를 사용하는 프로그래머가 그 기능을 정의하도록 강제하는 장치이다.