# 2018.10.26 TIL## BB Game### MapManager```using System.Collections;using System.Collections.Generic;using UnityEngine;public class BBMapManager : MonoBehaviour {	public static BBMapManager Instance { get; private set; }	public const float LeftLimit = -2.5f;	public const float TopLimit = 4f;	public const float width = 5;	public const float height = 4;	public const float x = 0.5f;	public const float y = 0.25f;	public int brickNum = 0;	public GameObject BrickOrigin;	int stage = 0;	// Use this for initialization	void Start () {		Instance = this;	}	void Stage1()	{				for (int j = 0; j < 10; j++)		{			for (int i = 0; i < width / x; i++)			{				if (j % 2 == 0)				{					GameObject brick = GameObject.Instantiate(BrickOrigin);					brick.SetActive(true);					brick.transform.position = new Vector3(LeftLimit + i * (x + 0.05f), TopLimit - j * (y + 0.05f), 0);					brickNum += 1;				}			}		}	}	void Stage2()	{		for (int j = 0; j < 10; j++)		{			for (int i = 0; i < width / x; i++)			{				if (j % 2 == i % 2) {					GameObject brick = GameObject.Instantiate(BrickOrigin);					brick.SetActive(true);					brick.transform.position = new Vector3(LeftLimit + i * (x + 0.05f), TopLimit - j * (y + 0.05f), 0);					brickNum += 1;				}			}		}	}	void Stage3()	{		for (int j = 0; j < 8; j++)		{			for (int i = 0; i < width / x; i++)			{				if (j * i % 2 == 0)				{					GameObject brick = GameObject.Instantiate(BrickOrigin);					brick.SetActive(true);					brick.transform.position = new Vector3(LeftLimit + i * (x + 0.05f), TopLimit - j * (y + 0.05f), 0);					brickNum += 1;				}			}		}	}	void Stage4()	{		for (int j = 0; j < 10; j++)		{			for (int i = 0; i < width / x; i++)			{				if (j % 2 == i % 2)				{					GameObject brick = GameObject.Instantiate(BrickOrigin);					brick.SetActive(true);					brick.transform.position = new Vector3(LeftLimit + i * (x + 0.05f), TopLimit - j * (y + 0.05f), 0);					brickNum += 1;				}			}		}	}	void Stage5()	{		for (int j = 0; j < 6; j++)		{			for (int i = 0; i < width / x; i++)			{				GameObject brick = GameObject.Instantiate(BrickOrigin);				brick.SetActive(true);				brick.transform.position = new Vector3(LeftLimit + i * (x + 0.05f), TopLimit - j * (y + 0.05f), 0);				brickNum += 1;			}		}	}	// Update is called once per frame	void Update () {		if(brickNum == 0)		{				stage++;			if (stage > 1)				BBGameManager.Instance.NextStage();			switch (stage)			{				case 1:					Stage1();					break;				case 2:					Stage2();					break;				case 3:					Stage3();					break;				case 4:					Stage4();					break;				case 5:					Stage5();					break;				default:					int i = Random.Range(1, 6);					if (i == 1) { Stage1(); }					if (i == 2) { Stage2(); }					if (i == 3) { Stage3(); }					if (i == 4) { Stage4(); }					if (i == 5) { Stage5(); }					break;			}		}	}}```1. MapManager에서는 스테이지 생성을 담당한다.2. 현재 맵에 남아있는 Brick의 개수를 체크하고, 0이 되면 GameManager의 NextStage()를 실행하며, GameManager는 isPlaying을 잠시 중단하고 321카운트를 실행한다. 그리고 게임이 다시 시작되면 MapManager의 Update가 다음 스테이지를 생성하게 된다.3. 5스테이지까지 마무리하면, 이후로는 1부터 5까지의 스테이지가 랜덤으로 재생성 되도록 한다.### GameManager```using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class BBGameManager : MonoBehaviour {	public float upgradeTime;	public static BBGameManager Instance { get; private set; }	public bool isPlaying;	public AudioClip BGMSound;	public int score = 0;	private float count = 0;	private AudioSource bgmSource;	// Use this for initialization	void Start()	{		Screen.SetResolution(Screen.width, (Screen.width * 16) / 9, true);		Time.timeScale = 1f;		Instance = this;		isPlaying = false;		bgmSource = GetComponent<AudioSource>();		bgmSource.PlayOneShot(BGMSound, 1f);	}	// Update is called once per frame	void Update()	{		if (isPlaying)		{			count += Time.deltaTime;			if (count >= upgradeTime)			{				count -= upgradeTime;				Ball.Instance.speed *= 1.1f;			}		}	}	public void GameOver()	{		BBUIManager.Instance.OpenGameOverPanel();		BBUIManager.Instance.PrintScore();		bgmSource.Stop();		isPlaying = false;	}	public void PauseGame()	{		BBUIManager.Instance.OpenPopUpPanel();		isPlaying = false;	}	public void ResumeGame()	{		BBUIManager.Instance.ClosePopUpPanel();		isPlaying = true;	}	public void ResetGame()	{		SceneManager.LoadScene(SceneManager.GetActiveScene().name);	}	public void BackToMenu()	{		SceneManager.LoadScene("MenuScene");	}	public void NextStage()	{		isPlaying = false;		Ball.Instance.transform.position = new Vector3(0, -3, 0);		Ball.Instance.direction = new Vector3(-1, -1, 0);		Bar.Instance.transform.position = new Vector3(0, -3.8f, 0);		BBUIManager.Instance.PrintCounting();	}}```1. MapManager에서 brickNum이 0이 되었을 때 NextStage()가 불리고, isPlaying이 false가 되어 게임 진행이 잠시 멈춘다.2. NextStage()에서는 Ball과 Bar의 위치가 초기화되며, UIManager의 PrintCounting()를 실행하여 3초카운트다운을 한다. (이때 UIManager에서 isPlaying을 true로 바꿈)3. 이때, 점수와 스피드에는 영향이 가지 않는다.### 기타 수정사항1. NGUI의 Button의 collider와 공의 Collider가 부딪히는 것같아 UI GameObject를 비활성화 하고, UIManager에서 관리할 때에 TweenAlpha가 아닌 GameObject를 SetActive하는 방법으로 끄고 켰다.2. 테두리(Limit)의 sprite가 깨지는 것 같아 교체.3. Brick의 Collider가 겹치지 않도록 수정.4. 