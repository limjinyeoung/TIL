﻿﻿﻿﻿﻿﻿﻿﻿# 2018.07.05 TIL## Unity### PrefabManager1. prefabManager Script```using System.Collections;using System.Collections.Generic;using UnityEngine;public class PrefabManager : MonoBehaviour {    public static PrefabManager Instance { private set; get; }    public GameObject bullet;    public GameObject effect_Attacked;    public GameObject enemy;    public void Awake()    {        Instance = this;    }}``` - 역할 : 다른 script 에서 prefab에 접근하기 용이하도록 정리하여 모아둠. - 현재까지의 prefab  -1. bullet : 플레이어가 발사하는 총알. 플레이어는 Bullet.Generate()로 Bullet class에 있는 static 메소드인 Generate()로 접근하고, 실질적인 생산은 Bullet의 메소드에서 실행. -2 effect_Attacked : bullet이 적에 닿았을 때 실행되는 particle effect. 실질적으로는 enemy 클래스의OnCollisionEnter메소드에서 실행한다. -3. enemy : enemy를 계속해서 생산하기위해 GameManager클래스에서 원본으로써 사용한다. 2. 사용방법  - prefabManager는 scale은 1로, position은 0으로 초기화하여야 사용하기 쉬운 것 같다...(prefabManager의 하위오브젝트들이 local scale과 position으로 적용되기때문에..) - PrefabManager script의 public 변수들을 채워넣는것을 잊지 말자### Bullet1. Bullet script```using System.Collections;using System.Collections.Generic;using UnityEngine;public class Bullet : MonoBehaviour {    public float shootingSpeed;    private GameObject shooter;    private Rigidbody rb;    private Vector3 movingVector;    public static GameObject Generate(GameObject shooter)    {        GameObject origin = PrefabManager.Instance.bullet;        GameObject bullet = Instantiate(origin);        Bullet script = bullet.GetComponent<Bullet>();        script.shooter = shooter;        bullet.SetActive(true);        bullet.name = "bullet";        return bullet;    }    // Use this for initialization    void Start () {        this.transform.position = shooter.transform.position + shooter.transform.forward * 1f + shooter.transform.up * 0.5f; ;        rb = this.GetComponent<Rigidbody>();        this.transform.LookAt(shooter.transform.position+shooter.transform.up*0.5f+shooter.transform.forward*2f);	}    		// Update is called once per frame	void Update () {        movingVector = this.transform.forward * 1f;        rb.velocity = new Vector3(movingVector.normalized.x, movingVector.normalized.y, movingVector.normalized.z)*shootingSpeed;    }    private void OnCollisionEnter(Collision collision)    {        if(collision.transform.tag != "Player") Destroy(this.gameObject);    }}``` - bullet은 space가 눌렸을 때, player script에서 불려서 실행되는 Generate로 생성된다. 2. Generate - Generate는 매개변수로 GameObject shooter가 필요한데, player script에서 자기자신의 GameObject를 보내게 된다. - Genarate는 생성할 Object의 원본(origin)을 prefabManager에서부터 가져오고 Bulletscript를 붙임으로써 shooter를 player로 초기화 할 수 있도록 한다. 또한, SetActive(true)를 해야 bullet이 start된다.3. bullet의 start, update - bullet이 생성되면 먼저 player를 기준으로 약간 앞쪽으로 position을 잡고, 방향은 player의 forward쪽으로 초기화한다. 또, 미리 rigidbody를 getComponent한다. - 한번 초기화된 방향은 이후에 꺾일 일이 없기 때문에, update에서는 velocity를 총알의 forward벡터방향 shootingSpeed의 속도로 지정하기만 한다.4. OncollisionEnter - Player 외의 Object에 부딪힌 경우, 총알이 소멸하도록 한다.### Effect_Attacked1. Effect_Blood - 배경색이 투명한 둥근 피의 PNG 이미지 파일을 Particles/Alpha Blended 셰이더로 적용시킨다. - billboard mode의 사방에서 볼 수 있는 피 효과. - Box Shape를 사용하여, Position과 scale을 0으로 고정하여 정확히 가운데에서 움직이지 않고 effect를 실행할 수 있도록 한다. - Loop없이 한번만 실행되며, size over lifetime을 적용하여 서서히 번지는 효과를 연출한다.  - color over lifetime을 적용하여 서서히 색이 사라지도록 하여 자연스럽게 보이도록 한다.2. Effect_BloodSpout - 배경색이 투명한 튀기는듯한 피의 PNG 이미지 파일을 Particles/Alpha Blended 셰이더로 적용시킨다. - stretched Billboard mode의 방향성을 가지고 튀기는 연출이 가능한 효과 - cone Shape를 적용하여 첫 angle은 좁게(0.1), angle은 넓게(50) 잡아서 전방으로 튀기는 연출이 가능하도록 한다. - color over lifetime을 적용하여 서서히 색이 사라지도록 하여 자연스럽게 보이도록 한다.3. Effect_Attacked - 위의 두가지 particle을 하위오브젝트로 포함하는 GameObject. - prefabManager의 하위오브젝트로서, 비활성화되어있지만, enemy가 bullet과 충돌하면 인스턴스화되어 활성화된다.### Enemy1. Enemy script```using System.Collections;using System.Collections.Generic;using UnityEngine;public class Enemy : MonoBehaviour {    public float speed;    private Animation Ani;    private bool isAlive;    private bool isJumping;    private Rigidbody rb;    public static GameObject GenerateEnemy()    {        GameObject enemy = GameObject.Instantiate(PrefabManager.Instance.enemy);        enemy.transform.position = new Vector3(Random.Range(-110, -15), 50, Random.Range(-10, 100));        enemy.transform.Rotate(enemy.transform.up * Random.Range(0, 360));        enemy.SetActive(true);        return enemy;    }    // Use this for initialization    void Start () {        rb = GetComponent<Rigidbody>();        isJumping = false;        isAlive = true;        Ani = this.GetComponent<Animation>();        if (!Ani.isPlaying)        {            Ani.CrossFade("Idle");        }    }		// Update is called once per frame	void Update () {        if (isAlive)        {            if (!Ani.isPlaying) Ani.Play("Move");            if (!isJumping) jump();            rb.velocity = new Vector3(this.transform.forward.x*speed, rb.velocity.y, this.transform.forward.z*speed);        }    }    private void jump()    {        rb.AddForce(Vector3.up * 300f);        isJumping = true;    }    private void OnCollisionEnter(Collision collision)    {        if (isAlive)        {            isJumping = false;            if (collision.transform.tag == "Obstacle") this.transform.Rotate(this.transform.up, 160);            if (collision.transform.tag == "Bullet")            {                Ani.Play("Death");                isAlive = false;                GameObject effect_Attacked = GameObject.Instantiate(PrefabManager.Instance.effect_Attacked);                effect_Attacked.transform.position = collision.transform.position;                effect_Attacked.transform.LookAt(collision.transform.forward * -1f);                effect_Attacked.SetActive(true);                StartCoroutine(DestroyGameObject(this.gameObject, 5));                StartCoroutine(DestroyGameObject(effect_Attacked, 1));            }        }    }    IEnumerator DestroyGameObject(GameObject go, float seconds)    {        yield return new WaitForSeconds(seconds);        GameObject.DestroyImmediate(go);    }}``` - Enemy는 5초에 한번씩 GameManager script에서 불려서 실행되는 GenerateEnemy로 생성된다. 2. GenerateEnemy()  - prefabManager에서 원본(origin)인 Enemy를 가져와 인스턴스화한다. - position은 맵상에 가능한 random값을 지정하고, rotation도 random으로 지정한다. - setActive(true)로 이 인스턴스가 활성화되어 start, update될 수 있도록 한다.3. start, update  - start : update 시 필요한 변수들을 초기화.(isJumping, isAlive), Animation과 rigidbody component를 불어옴. - update : enemy가 isAlive한지 검사한 후, 애니메이션을 갱신하고, 점프하는상태가 아니라면 점프하도록함. 움직이는 방향은 forward로 고정하여 일정한 speed로 이동.4. onCollisionEnter - Obstacle과 충돌했다면 방향을 rotate -  bullet과 충돌했을 시, Death애니메이션을 실행시키고, isAlive를 false로 바꾸고, Effect_Attacked를 실행시킨다. 이 때, Effect_Attacked는 1초 뒤에 사라지고, enemy GameObject는 5초뒤에 사라지도록 ,StartCoroutine을 사용한다.### GameManager1. GameManager script```using System.Collections;using System.Collections.Generic;using UnityEngine;public class GameManager : MonoBehaviour {	// Use this for initialization	void Start () {        for(int i = 0; i < 10; i++) Enemy.GenerateEnemy();    }    float genTime;	// Update is called once per frame	void Update () {        genTime += Time.deltaTime;        if(genTime > 5)        {            Enemy.GenerateEnemy();            genTime = 0;        }            }}``` - GameManager 는 게임 시작시 활성화되는 GameManager 게임오브젝트의 컴포넌트로 넣는다.2. GameStart시 먼저 Enemy를 10개 만들고, 5초에 한번씩 Enemy를 생성한다.