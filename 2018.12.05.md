# 2018.12.05 TIL## Brick Shader### Specular Map```Shader "Custom/NormalSpec"{    Properties	{		_MainTex ("Texture", 2D) = "white" {}		_NormalTex("Normal Map", 2D) = "white" {}		_LightPos("LightPos", Vector) = (0,0,0)    }    SubShader    {        Tags { "RenderType"="Opaque" }        LOD 100        Pass        {            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma multi_compile_fog                        #include "UnityCG.cginc"            struct appdata            {                float4 vertex : POSITION;                float2 uv : TEXCOORD0;				float3 normal : NORMAL;            };            struct v2f            {                float2 uv : TEXCOORD0;                UNITY_FOG_COORDS(1)                float4 vertex : SV_POSITION;				float3 normal : TEXCOORD1;				float3 worldPos : TEXCOORD2;            };                        sampler2D _NormalTex;            sampler2D _MainTex;                        float4 _NormalTex_ST;            float4 _MainTex_ST;			float3 _LightPos;                        v2f vert (appdata_base v)            {                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);				o.worldPos = v.vertex;                o.uv = v.texcoord;				o.normal = v.normal;                return o;            }                        fixed4 frag (v2f i) : SV_Target            {                float2 normCoord = i.uv;                fixed4 norm = tex2D(_NormalTex, normCoord);				float3 pointToCam = normalize(_WorldSpaceCameraPos - i.worldPos);				float3 lightVector = normalize(-_LightPos + i.worldPos);				float3 finalNorm = i.normal + (norm - 0.5) * 0.3;				float3 camVector = reflect(pointToCam, finalNorm);				float dotValue = dot(normalize(camVector), normalize(lightVector));				if (dotValue < 0) dotValue = 0;				float colorDot = dot(finalNorm, -lightVector);				if (colorDot < 0) colorDot = 0;								float3 colorDefault = tex2D(_MainTex, i.uv);				float3 finalColor = colorDefault * 0.4 + colorDefault * 0.6 * colorDot;				float3 specColor = float3(1, 1, 1) * pow(dotValue, 200);				return float4(finalColor + specColor, 1);            }            ENDCG        }    }}```1. MainTexture와 Normal Map, LightPosition은 Material을 적용시킬 때 받아올 수 있도록 한다.2. LightPos는 vector3의 위치로 나타내니 float3로 선언한다.3. flag에서 처리를 시작하면, normal Map의 처리를 먼저 한다. 일단 uv를 받아올 normCoord(float2 형식)를 선언하고, normal Texture와 normCoord를 매치시켜 얻은 norm (fixed4형식)을 구한다.4. pointTocam의 벡터는, WorldSpaceCameraPos (현재 시점위치)에서 i.worldPos (점의 위치)를 빼서 normalize하여 만든 것이다. 즉, 점에서 현재 카메라 시점방향으로의 벡터이다.5. lightVector는 i.worldPos(점의 위치)에서 LightPos(광원 위치)를 빼서 normalize하여 만든 것이다. 즉, 광원에서부터 점으로의 벡터이다.6. finalNorm은 노말맵의 영향력을 조절한다. i.normal(면이바라보는 벡터) + (norm-0.5) * (0.3) 인데, 이때 0.3은 normal 벡터의 영향력을 줄이기 위해 들어간 수치이고, norm에 -0.5한것은, norm 이 0부터 1까지를 표현하게되면 한쪽으로 치우치기 때문에 -0.5부터 0.5까지의 범위를 갖게 하기 위함이다.7. camVector는 pointTocam(점에서 카메라로의 벡터)와 finalNorm(노말맵)을 reflect하여 얻은 값이다. 즉, 카메라에서 점에 반사되어 나가는 벡터이다.8. dotValue는 camVector(카메라에서 점에 반사되어 나가는 벡터)와 lightVector(광원에서부터 점으로의 벡터)가 같은수록 1에 가깝고 다를수록 -1에 가깝다. (이때, 0보다 작다면 0이되게 한다.9.colorDot은 finalNorm(노말맵이 바라보는 벡터)과 -lightVector(점에서부터 광원으로의 벡터)가 같은 수록 1, 다를수록 0에 가깝다. (이때, 0보다 작다면 0이 되게 한다.)10. finalColor는 일정비율의 택스쳐 자체에 ColorDot을 섞은 텍스쳐이다.11. specColor는 빛을 나타내는 floate(1,1,1) gmlstordp dotValue의 변화량을 극적으로 하기 위해 200번 pow한 값을 곱한다.12. 결과적으로, finalcolor와 secColor를 더한 색을 return한다.### 내일할일1. 복습. 물결 spec 해보기~