# 2018.10.04 TIL## PooGame### Bomb 오브젝트 관리```using System.Collections;using System.Collections.Generic;using UnityEngine;public class PooPrefabManager : MonoBehaviour{	public static PooPrefabManager Instance { private set; get; }	public GameObject Bomb;	public void Awake()	{		Instance = this;	}}```1. PooPrefabManager를 생성하여 static으로 Instance를 외부 스크립트에서 사용할 수 있도록 한다.2. Bomb 오브젝트는 사전에 비활성화되어있어야 하며, PooPrefabManager 오브젝트에서Bomb로 등록되어있어야 한다.3. PooBomb Script에서는 PooPrefabManager.Instance.Bombfmf Instantiate하고 , SetActive한다.### 2D world에서의 UI1. UI Root 내부의 Camera에서, Projection은 Orthographic으로 설정되어야 한다.2. 버튼 클릭을 위하여, UI Root의 Camera의 UI Camera Script의 EventType은 2D World로 설정 되어야 한다. (이벤트 입력을 관리하는듯.)3. 언제나 해상도에 맞도록, 배경Sprite나 UI Sprite는 충분히 커야한다. 또한, 어떠한 해상도에도 플레이가 가능해야 하므로, Player의 위치 제한이나 Bomb의 생성 위치 등 화면의 크기 수치가 필요한 데에는 Screen.width를 사용한다.4. UI중 버튼이나 Label의 위치는 Anchors를 unified로 설정 한 후, 좌우중 한 곳과 위 아래중 한 곳을 기준삼아 수치를 정하면 쉽게 대응된다. (+UI Root의 Script에서의 Scaling Style은 Constrained On Mobiles로 해두었다.. )### UIManager Script```using System.Collections;using System.Collections.Generic;using UnityEngine;public class PooUIManager : MonoBehaviour {	public static PooUIManager Instance { get; private set; }	public TweenAlpha Popup;	public TweenAlpha GameOverPopup;	public GameObject HighScorePanel;	public GameObject Count0;	public GameObject Count1;	public GameObject Count2;	public GameObject Count3;	public UILabel ScoreLabel;	public UILabel HighScoreLabel;	public UILabel TimeLabel;	public float time = 0;	public AudioClip ClickSound;	public AudioClip BeatSound;	private AudioSource audioSource;	// Use this for initialization	void Start () {		Instance = this;		PrintCounting();		audioSource = GetComponent<AudioSource>();	}	public void PrintCounting()	{		Count3.SetActive(true);		StartCoroutine(Count());	}	IEnumerator Count()	{		yield return new WaitForSeconds(1);		Count3.SetActive(false);		Count2.SetActive(true);		yield return new WaitForSeconds(1);		Count2.SetActive(false);		Count1.SetActive(true);		yield return new WaitForSeconds(1);		Count1.SetActive(false);		Count0.SetActive(true);		yield return new WaitForSeconds(1);		Count0.SetActive(false);		PooGameManager.Instance.isPlaying = true;	}	// Update is called once per frame	void Update()	{		if(PooGameManager.Instance.isPlaying)		{			time += Time.deltaTime;			TimeLabel.text = "Score : " + ((int)time).ToString();		}	}	public void PrintScore()	{		ScoreLabel.text = "Score : " + TimeLabel.text;		HighScoreLabel.text = "High Score : " + GetHighScore();	}	public int GetHighScore()	{		if (PlayerPrefs.HasKey("HighScore"))		{			if (PlayerPrefs.GetInt(("HighScore")) < (int)time)			{				PlayerPrefs.SetInt("HighScore", (int)time);				StartCoroutine(PrintHighScore());			}		}		else		{			PlayerPrefs.SetInt("HighScore", (int)time);		}		PlayerPrefs.Save();		return PlayerPrefs.GetInt("HighScore");	}	IEnumerator PrintHighScore()	{		yield return new WaitForSeconds(2);		HighScorePanel.SetActive(true);		audioSource.PlayOneShot(BeatSound, 1f);	}	public void OnClickListenerPauseButton()	{		audioSource.PlayOneShot(ClickSound, 1f);		PooGameManager.Instance.PauseGame();	}	public void OnClickListenerResumeButton()	{		audioSource.PlayOneShot(ClickSound, 1f);		PooGameManager.Instance.ResumeGame();	}	public void OnClickListenerResetButton()	{		audioSource.PlayOneShot(ClickSound, 1f);		PooGameManager.Instance.ResetGame();	}	public void OnHighScoreResetButtonListener()	{		audioSource.PlayOneShot(ClickSound, 1f);		PlayerPrefs.SetInt("HighScore", 0);		HighScoreLabel.text = "High Score : " + "0";	}	public void OnClickListenerMenuButton()	{		PooGameManager.Instance.BackToMenu();	}	public void OpenPopUpPanel()	{		Popup.enabled = true;		Popup.PlayForward();	}	public void ClosePopUpPanel()	{		Popup.PlayReverse();	}	public void OpenGameOverPanel()	{		GameOverPopup.enabled = true;		GameOverPopup.PlayForward();	}}```1. CountDown방법은 CRT에서 썼듯이 IEnumerator를 사용하여 카운트한다. (이 때, timeScale을 변경하지 않고, PooGameManager에 isPlaying 변수를 생성하여 이것을 조절하는 방식으로 게임의 상태를 변경한다.)2. Update()에서는 score (즉, 시간)를적절한 Label에 적용하는 역할만 한다.3. PooGameManager에서 불리는 PrintScore()는 CRT에서 썼던 PrintScore()와 GetHighScore(), PrintHighScore()를 재사용했다. (High Score라면 사운드와 sprite를 추가하는 것 역시 적용시킴.) 단, 이때 CRT의 데이터와 겹치지 않도록 PlayerPrefs의 key를 "HighScore"로 변경했다.4. CRT보다 더 정렬된 코드를 위하여, OnClick 메소드와 Open메소드, Close메소드를 각각 분리하였다. (가독성이 좋아진듯 하다.) 모든 버튼 클릭은 UIManager에서 받고, 그에대한 처리는 GameManager로 넘기면서, GameManager에서 다시 UI로 접근할 때에 연결해주는 역할만을 하도록 했다. (사실 Update없이 GameManager에서 시간을 관리해도 좋겠다는 생각을 방금 했다.잠깐이거 너무 의식의 흐름인가)5. 게임 플레이시 Alpha값이 0인 Panel의 버튼도 클릭이 되는 문제가 발생한다. 이것은 어떻게 해결 해야할까...?6. 모든 버튼 클릭시 audioSource에서 Click Sound가 나오도록 한다.### GameManager Script```using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class PooGameManager : MonoBehaviour {	public float regenTime;	public static PooGameManager Instance { get; private set; }	public bool isPlaying;	public AudioClip BGMSound;	int upgradeRegenTime = 20;	float count = 0.0f;	private AudioSource bgmSource;	// Use this for initialization	void Start () {		Time.timeScale = 1f;		Instance = this;		isPlaying = false;		bgmSource = GetComponent<AudioSource>();		bgmSource.PlayOneShot(BGMSound, 1f);	}		// Update is called once per frame	void Update () {		if (isPlaying)		{			count += Time.deltaTime;			if (count >= regenTime)			{				count -= regenTime;				PooBomb.GenerateBomb();			}			if (PooUIManager.Instance.time > upgradeRegenTime)			{				upgradeRegenTime += 10;				regenTime *= 0.9f;			}		}	}	public void GameOver()	{		PooUIManager.Instance.OpenGameOverPanel();		PooUIManager.Instance.PrintScore();		bgmSource.Stop();		isPlaying = false;	}	public void PauseGame()	{		PooUIManager.Instance.OpenPopUpPanel();		isPlaying = false;	}	public void ResumeGame()	{		PooUIManager.Instance.ClosePopUpPanel();		isPlaying = true;	}	public void ResetGame()	{		SceneManager.LoadScene(SceneManager.GetActiveScene().name);	}	public void BackToMenu()	{		SceneManager.LoadScene("MenuScene");	}}```1. 오류 방지를 위해 Time.timeScale을 Start()시에 1f로 정해둔다.2. 시작과동시에 CountDown이 시작되기 때문에, isPlaying은 flase이고, Game의 BGM은 Countdown에도 흘러나오도록 Start에서 Play한다.3. upgradeRegenTime은 regen 속도가 빨라지도록 할 때, 몇초마다 빨라질지를 결정한다. UI의 time을 가져와 비교하며 regenTime을 조절한다. (음수가 되지 않도록 *0.09를 했다.)4. GameOver시 GameOverPanel을 띄우고, 점수집계를 하며, 게임과 음악을 멈춘다.5. PauseGame과 ResumeGame을 분리 (CRT에서는 SwitchStatus로 상태를 바꾸었었다.)하여 가독성을 높였다.6. ResetGame은 현재의 게임씬을 다시 로드하고, BackToMenu는 Menu씬을 로드한다!## Menu### MenuManager```using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class MenuManager : MonoBehaviour {	// Use this for initialization	void Start () {			}		// Update is called once per frame	void Update () {			}	public void OnClickPooGame()	{		SceneManager.LoadScene("PooScene");	}	public void OnClickCRT()	{		SceneManager.LoadScene("CRTScene");	}}```1. MenuManager는 CRT와 Poo Scene으로의 접근을 관리한다. 즉, 사용자가 MenuScene에서 두 게임중 하나를 선택해서 들어갈 수 있도록 한다.2. 코드는 간단히, 각 게임의 버튼이 눌리면 SceneManager.LoadScene("씬이름"); 으로 해당 씬을 플레이 한다는 코드이다.3. 버튼은 그냥 버튼이 아니라 각 게임의 스크린샷을 버튼삼았다. (이 때, Atlas를 수정하여 사용)4. 같은 방식으로, 각 씬에서 Back To Menu버튼을 누르면 MenuScene으로 돌아올 수 있도록 OnClickListener를 달고 코딩을 한다. (2D와 3D에서의 버튼환경은 다르다..!)5. ctrl+shift+b 로 BuildSeetting를 열고 한번에 Build할 씬을 등록해 두어야 씬끼리의 이동이 가능하다!!