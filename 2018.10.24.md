# 2018.10.25 TIL## BBGame### Ball```using System.Collections;using System.Collections.Generic;using UnityEngine;public class Ball : MonoBehaviour {	public float speed;	public static Ball Instance { get; private set; }	Vector3 direction = new Vector3(-1, -1, 0);	// Use this for initialization	void Start () {		Instance = this;	}		// Update is called once per frame	void Update () {		if (BBGameManager.Instance.isPlaying)		{			this.transform.position += direction.normalized * speed * 0.01f;		}	}	public void OnCollisionEnter2D(Collision2D collision)	{		if (collision.transform.tag == "LimitLeft")			direction.x = -direction.x;		else if (collision.transform.tag == "LimitBottom")			direction.y = -direction.y;		else if(collision.transform.tag == "LimitRight")			direction.x = -direction.x;		else if (collision.transform.tag == "LimitTop")			direction.y = -direction.y;		else if (collision.transform.tag == "Bar")		{			direction.x += this.transform.position.x - collision.transform.position.x;			direction.y = -direction.y;		}		else if (collision.transform.tag == "GameOverLine")		{			BBGameManager.Instance.GameOver();		}	}}```1. brick과 Limit는 tag를 공유하는데, 각 벽의 위치에 따라 반사각이 다르다는 사실을 공유하므로 이렇게 했다. (후에 후회했다... 겁내 헷갈리네)2. Bar와의 충돌검사를 더 사실적인 각도 묘사가 가능하다면 좋겠다. 다른 사람들이 만든 script를 확인할 필요가 있다.### GameManager```using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class BBGameManager : MonoBehaviour {	public float upgradeTime;	public static BBGameManager Instance { get; private set; }	public bool isPlaying;	public AudioClip BGMSound;	public int score = 0;	private float count = 0;	private AudioSource bgmSource;	// Use this for initialization	void Start()	{		Screen.SetResolution(Screen.width, (Screen.width * 16) / 9, true);		Time.timeScale = 1f;		Instance = this;		isPlaying = false;		bgmSource = GetComponent<AudioSource>();		bgmSource.PlayOneShot(BGMSound, 1f);	}	// Update is called once per frame	void Update()	{		if (isPlaying)		{			count += Time.deltaTime;			if (count >= upgradeTime)			{				count -= upgradeTime;				Ball.Instance.speed *= 1.1f;			}		}	}	public void GameOver()	{		BBUIManager.Instance.OpenGameOverPanel();		BBUIManager.Instance.PrintScore();		bgmSource.Stop();		isPlaying = false;	}	public void PauseGame()	{		BBUIManager.Instance.OpenPopUpPanel();		isPlaying = false;	}	public void ResumeGame()	{		BBUIManager.Instance.ClosePopUpPanel();		isPlaying = true;	}	public void ResetGame()	{		SceneManager.LoadScene(SceneManager.GetActiveScene().name);	}	public void BackToMenu()	{		SceneManager.LoadScene("MenuScene");	}}```1. Poo Game의 GameManager와 비슷한 형태로 만들었다. Update 시에 난이도조절부분만 수정하면 거의 똑같이 사용할 수 있다. 2. BackGroundAudio는 바꾸어야 할 필요가 있다### UIManager```using System.Collections;using System.Collections.Generic;using UnityEngine;public class BBUIManager : MonoBehaviour {	public static BBUIManager Instance { get; private set; }	public TweenAlpha Popup;	public TweenAlpha GameOverPopup;	public GameObject HighScorePanel;	public GameObject Count0;	public GameObject Count1;	public GameObject Count2;	public GameObject Count3;	public UILabel IngameScore;	public UILabel ScoreLabel;	public UILabel HighScoreLabel;	public AudioClip ClickSound;	public AudioClip BeatSound;	private int score = 0;	private AudioSource audioSource;	// Use this for initialization	void Start()	{		Instance = this;		PrintCounting();		audioSource = GetComponent<AudioSource>();	}	public void PrintCounting()	{		Count3.SetActive(true);		StartCoroutine(Count());	}	IEnumerator Count()	{		yield return new WaitForSeconds(1);		Count3.SetActive(false);		Count2.SetActive(true);		yield return new WaitForSeconds(1);		Count2.SetActive(false);		Count1.SetActive(true);		yield return new WaitForSeconds(1);		Count1.SetActive(false);		Count0.SetActive(true);		yield return new WaitForSeconds(1);		Count0.SetActive(false);		BBGameManager.Instance.isPlaying = true;	}	// Update is called once per frame	void Update()	{		score = BBGameManager.Instance.score;		if (BBGameManager.Instance.isPlaying)		{			IngameScore.text = "점수 : " + score ;		}	}	public void PrintScore()	{		ScoreLabel.text = "점수 : " + (int)score;		HighScoreLabel.text = "최고점수 : " + GetHighScore();	}	public int GetHighScore()	{		if (PlayerPrefs.HasKey("HighBBScore"))		{			if (PlayerPrefs.GetInt(("HighBBScore")) < score)			{				PlayerPrefs.SetInt("HighBBScore", score);				StartCoroutine(PrintHighScore());			}		}		else		{			PlayerPrefs.SetInt("HighBBScore", score);		}		PlayerPrefs.Save();		return PlayerPrefs.GetInt("HighBBScore");	}	IEnumerator PrintHighScore()	{		yield return new WaitForSeconds(2);		HighScorePanel.SetActive(true);		audioSource.PlayOneShot(BeatSound, 1f);	}	public void OnClickListenerPauseButton()	{		audioSource.PlayOneShot(ClickSound, 1f);		BBGameManager.Instance.PauseGame();	}	public void OnClickListenerResumeButton()	{		audioSource.PlayOneShot(ClickSound, 1f);		BBGameManager.Instance.ResumeGame();	}	public void OnClickListenerResetButton()	{		audioSource.PlayOneShot(ClickSound, 1f);		BBGameManager.Instance.ResetGame();	}	public void OnHighScoreResetButtonListener()	{		audioSource.PlayOneShot(ClickSound, 1f);		PlayerPrefs.SetInt("HighBBScore", 0);		HighScoreLabel.text = "최고점수 : " + "0";	}	public void OnClickListenerMenuButton()	{		//PooGameManager.Instance.BackToMenu();	}	public void OpenPopUpPanel()	{		Popup.enabled = true;		Popup.PlayForward();	}	public void ClosePopUpPanel()	{		Popup.PlayReverse();	}	public void OpenGameOverPanel()	{		GameOverPopup.enabled = true;		GameOverPopup.PlayForward();	}}```1. Poo Game의 UIManager를 재사용했다. 이 때, PlayerPrefs에 들어가는 변수의 이름을 수정하는 것을 잊지 않아야 하고, UI의 연결도 다시 해야 한다.2. UI를 만들때에도 PooGame의 UI Root를 가져왔는데, 왜인지 RigidBody가 붙어있었다....왜째서....? 내 Ball이 이상하게 움직이기때문에 Remove했다.3. Resource가 다르기 때문에 Atlas를 새로 만들었지만, 실제로 UI에 쓰이는 sprite들은 다른 게임과 똑같기 때문에 Atlas를 새로 만들지 않아도 될 뻔했다. (이때 Atlas 관리를 어떻게 해야 할까)### 이외의 수정사항1. collider가 겹쳐서 Ball의 움직임이 이상하다고 느껴져 각 Brick의 생성위치가 떼어지도록 했다. Vector3(LeftLimit + i * (x +0.05f), TopLimit - j * (y+0.05f), 0);2. brick과 Ball의 Resource관리가 필요.