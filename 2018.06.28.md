﻿﻿﻿﻿﻿#2018.06.28##Unity - Overwatch### Player Script```using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour {    public float jumpSpeed;    public float speed;    private Rigidbody rb;    private Vector3 vMouse = new Vector3();    private Vector3 movingVector;    private bool isJumping;    // Use this for initialization    void Start () {        rb = GetComponent<Rigidbody>();        isJumping = true;	}    // Update is called once per frame    void Update()    {        movingVector = new Vector3(0, 0, 0);        if (Input.GetKey(KeyCode.D))        {            movingVector += this.transform.right* 0.1f;        }        if (Input.GetKey(KeyCode.A))        {            movingVector += this.transform.right*-0.1f;        }        if (Input.GetKey(KeyCode.W))        {            movingVector += this.transform.forward*0.1f;        }        if (Input.GetKey(KeyCode.S))        {            movingVector = this.transform.forward*-0.1f;        }        rb.velocity = new Vector3(movingVector.normalized.x*speed, rb.velocity.y, movingVector.normalized.z*speed);        if (Input.GetKeyDown(KeyCode.Space))        {            if (!isJumping) jump();        }        Vector3 deltaMousePosition = Input.mousePosition - vMouse;        this.transform.Rotate(this.transform.up * deltaMousePosition.x);        this.vMouse = Input.mousePosition;    }    private void OnCollisionEnter(Collision collision)    {        isJumping = false;    }    private void jump()    {        rb.AddForce(Vector3.up * jumpSpeed);        isJumping = true;    }}```1. Player position - Player는 asdw키를 입력받아 이동하는데, 중요한것은 입력받은 즉시 벡터를 적용시키는 것이 아니라, 모든 입력이 끝난 후, 합쳐진 벡터를 normalize하여 speed를 고정하는 것이다. - player object가 중력의 영향을 받기 때문에, x,z 방향의 벡터값만 asdw키로 바꿀 수 있게 한다. y벡터는 중력에 의해 자연스레 변화하도록 한다. (어떠한 물체와 player가 닿아있을 때, 중력의 작용이 어색함.수정 필요) - Jump는 Rigidbody의 AddForce 메소드를 사용하여 up벡터방향으로 힘을 주는 방법으로 점프를 한다. (점프치고 약간 어색해서 수정이 필요할 듯)2. Player Rotation - Rotation은 마우스가 움직이는 방향대로 Player가 회전하도록 한다. - 이전 프레임의 마우스 위치 벡터를 기억하고 변화량에 따라 회전량을 정하는 방식으로 회전시킨다.3. Jump - jump는 y벡터만으로 하는데, space입력이 들어올때마다 rigidbody의 addForce를 통해 up벡터 방향으로 힘을 가하여 점프한다. 후에 중력에 의해 y값이 점점 낮아지게 내버려둔다. - 2단 이상의 jump를 막기 위해, isJumping을 두고, 점프를 하면 true로, Object에 부딪히면(착지하면) false로 바뀌게 하여 점프상태를 확인하여 점프하도록 한다.### Camera Script```using System.Collections;using System.Collections.Generic;using UnityEngine;public class camera : MonoBehaviour {    public GameObject player;    public float zoomSpeed;    private float camDistanceToTarget;    private float cHeight;    private Vector3 vMouse;	// Use this for initialization	void Start () {        camDistanceToTarget = 5;        cHeight = 1;	}		// Update is called once per frame	void Update () {        this.transform.position = player.transform.position+(player.transform.up*cHeight- player.transform.forward).normalized*camDistanceToTarget;        this.transform.LookAt(player.transform.position);        if (Input.GetAxis("Mouse ScrollWheel") < 0 && camDistanceToTarget<100)        {            camDistanceToTarget += zoomSpeed;        }        if (Input.GetAxis("Mouse ScrollWheel") > 0 && camDistanceToTarget>5)        {            camDistanceToTarget -= zoomSpeed;        }        Vector3 deltaMousePosition = Input.mousePosition - vMouse;        cHeight -= deltaMousePosition.y*0.01f;        if (cHeight < 0) cHeight = 0;        if (cHeight > 1) cHeight = 1;        this.vMouse = Input.mousePosition;    }}```1. camera position - camera는 player의 후방 상단에 위치한다. position이나 rotation이 바뀌더라도 player를 바라볼 수 있도록 LookAt()을 사용한다. - up벡터에 cHeight를 곱한 벡터와 forward벡터(-) 를 더하여 normalize한 후, camDistanceToTarget만큼 곱한 위치에 카메라를 위치시킨다.  - cHeight는 마우스의 위아래 움직임에 따라 플레이어를 바라보는 각도를 조절하기 위한 수치이다. 마우스의 y벡터 변화량이 cHeight에 영향을 미치며, 최댓값과 최솟값을 한정지어 카메라가 이상한 각도로 피사하는 것을 막는다.2. camera Zoom - zoom은 마우스 휠을 입력받아 camDistance를 조절하는 것으로 할 수 있다. - camDistanceToTarget의 최솟값과 최댓값을 한정지어야 카메라가 player의 후방 상단에 위치하도록 할 수 있다. (-로 가면 아래에서 보게 된다.### Map1. Asset Store - Map에 대한 것은, 직접 만들것이 아니라면 Asset Store에서 무료로 (혹은 유료로) 사용할 수 있다! - 마음에 든 asset을 Import하여 폴더에 집어넣을 수 있고, 한번 다운받은 자료는 기록이 남아 다시 찾기 쉽다....2. Object 확인 - 처음 Map을 Asset store에서 사오면, scene이 있는데, 이 scene을 목적에 맞게 다시 다듬어야 한다. - 산이나 나무, 바위등에 Collider를 추가하고, skybox를 등록하고, 필요없는 script를 걸러내는 등의 작업이 필요하다.3. limit - Map의 끝으로 가면 gravity에 의해 떨어진다. 이것을 방지하기 위하여, Map의 사방에 투명한 벽을 세워 경계를 만든다.