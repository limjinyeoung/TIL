# 2019.01.17## StellarWar### touchCamera```using System.Collections;using System.Collections.Generic;using UnityEngine;public class TouchCamera : MonoBehaviour{	public float MovingSpeed = 0.05f;	public float ZoomSpeed = 0.02f;	public float RotationSpeed = 1f;	public float SpeedScale = 1f;	public float DistToTarget = 30f;	public Vector3 TargetPoint;	public GameObject TargetObject;		// Start is called before the first frame update	private void Awake()	{		Input.simulateMouseWithTouches = true;	}	void Start()	{		if (TargetObject == null)		{			TargetPoint = new Vector3(0, 0, 0);		}		else		{			TargetPoint = TargetObject.transform.position;		}	}	// Update is called once per frame	void Update()	{		if (Input.touchCount == 1)		{			Touch touchA = Input.GetTouch(0);			TargetPoint += (-touchA.deltaPosition.x * MovingSpeed * this.transform.right) + (-touchA.deltaPosition.y * MovingSpeed * this.transform.up);			this.transform.position += (-touchA.deltaPosition.x * MovingSpeed * this.transform.right) + (-touchA.deltaPosition.y * MovingSpeed * this.transform.up);		}		else if (Input.touchCount == 2)		{			Touch touchA = Input.GetTouch(0);			Touch touchB = Input.GetTouch(1);			Vector2 touchAPrev = touchA.position - touchA.deltaPosition;			Vector2 touchBPrev = touchB.position - touchB.deltaPosition;			float distAB = (touchA.position - touchB.position).magnitude;			float distABPrev = (touchAPrev - touchBPrev).magnitude;						if (DistToTarget < 1f)			{				DistToTarget = 1f;			}			else			{				float deltaDist = distAB - distABPrev;				DistToTarget -= deltaDist * ZoomSpeed;			}			Vector2 vectorAB = touchA.position - touchB.position;			Vector2 vectorABPrev = touchAPrev - touchBPrev;			int sign = Vector3.Cross(vectorAB, vectorABPrev).z < 0 ? -1 : 1;			float angle = sign * Vector3.Angle(vectorAB, vectorABPrev);			this.transform.RotateAround(TargetPoint, Vector3.up, angle * RotationSpeed);			this.transform.position = TargetPoint + (this.transform.position - TargetPoint).normalized * DistToTarget;			this.transform.LookAt(TargetPoint);					}	}}```### clickToTouch```using System.Collections;using System.Collections.Generic;using UnityEngine;public class ClickToTouch : MonoBehaviour{	public float MovingSpeed = 0.05f;	public float ZoomSpeed = 0.02f;	public float RotationSpeed = 1f;	public float SpeedScale = 1f;	public float DistToTarget = 30f;	public Vector3 TargetPoint;	public GameObject TargetObject;	Vector2 touchA;	Vector2 touchAPrev;	Vector2 touchB;	Vector2 touchBPrev;	// Start is called before the first frame update	private void Awake()	{		Input.simulateMouseWithTouches = true;	}	void Start()	{		if (TargetObject == null)		{			TargetPoint = new Vector3(0, 0, 0);		}		else		{			TargetPoint = TargetObject.transform.position;		}	}	// Update is called once per frame	void Update()	{		if (Input.GetMouseButtonDown(0))		{			touchAPrev = Input.mousePosition;		}		else if (Input.GetMouseButton(0) && Input.GetKey(KeyCode.LeftAlt))		{			touchA = Input.mousePosition;			float distAB = (touchA - touchB).magnitude;			float distABPrev = (touchAPrev - touchBPrev).magnitude;			if (DistToTarget < 1f)			{				DistToTarget = 1f;			}			else			{				float deltaDist = distAB - distABPrev;				DistToTarget -= deltaDist * ZoomSpeed;			}						Vector2 vectorAB = touchA - touchB;			Vector2 vectorABPrev = touchAPrev - touchBPrev;			int sign = Vector3.Cross(vectorAB, vectorABPrev).z < 0 ? -1 : 1;			float angle = sign * Vector3.Angle(vectorAB, vectorABPrev);			if (Mathf.Abs(angle) > 3)			{				this.transform.RotateAround(TargetPoint, Vector3.up, angle * RotationSpeed);				this.transform.LookAt(TargetPoint);			}			this.transform.position = TargetPoint + (this.transform.position - TargetPoint).normalized * DistToTarget;		}		else if (Input.GetKey(KeyCode.LeftAlt) && !Input.GetKey(KeyCode.LeftAlt))		{			touchB = Input.mousePosition;			touchBPrev = touchB;		}		else if (Input.GetMouseButton(0))		{			touchA = Input.mousePosition;			TargetPoint -= ((touchA - touchAPrev).x * MovingSpeed * this.transform.right + (touchA - touchAPrev).y * MovingSpeed * this.transform.up);			this.transform.position -= ((touchA - touchAPrev).x * MovingSpeed * this.transform.right + (touchA - touchAPrev).y * MovingSpeed * this.transform.up);			touchAPrev = touchA;		}	}}```